// Copyright (c) <2015>, <maxd>
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this
   // list of conditions and the following disclaimer. 
// 2. Redistributions in binary form must reproduce the above copyright notice,
   // this list of conditions and the following disclaimer in the documentation
   // and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// The views and conclusions contained in the software and documentation are those
// of the authors and should not be interpreted as representing official policies, 
// either expressed or implied, of the FreeBSD Project.
var BarWithPercentLineChart = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el || "body";
	var minYBarDomainUpperValue = 1;
	var minYLineDomainUpperValue = .01;
	var barPaddingFraction = .2;
	this.barColor = chartKey.subjectName ? util.color(chartKey.subjectName) : "SteelBlue";
	this.lineColor = "#000";
	this.barLegendText = "Monthly Talks";
	this.lineLegendText = "Percent of Total Talks";
	var minWidth = 200;
	var minHeight = 100;
	var defaultDimension = {
		width : 280,
		height : 120
	};
	var defaultMargin = {
		top : 20,
		right : 80,
		bottom : 20,
		left : 40
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	};
	data.sort(function(a, b) {
		var numA = parseInt(a[chartKey.x]);
		var numB = parseInt(b[chartKey.x]);
		if (numA > numB) {
			return 1
		} else if (numA < numB) {
			return -1
		} else {
			return 0
		}
	});
	var xKey = chartKey.x;
	var maxKey = this.maxKey = d3.max(data, function(d) {
		return d[xKey]
	});
	var minKey = this.minKey = d3.min(data, function(d) {
		return d[xKey]
	});
	var yKey = chartKey.y;
	var barDataDomain = d3.extent(data, function(d) {
		return d.value[yKey.bar]
	});
	var lineDataDomain = d3.extent(data, function(d) {
		return d.value[yKey.line]
	});
	var maxYBar = barDataDomain[1];
	if (maxYBar === 0) {
		maxYBar = minYBarDomainUpperValue
	}
	var yBarFraction = util.getMostDec(maxYBar) * 2;
	var maxYLine = lineDataDomain[1];
	if (maxYLine === 0) {
		maxYLine = minYLineDomainUpperValue
	}
	var yLineFraction = util.getMostDec(maxYLine) * 2;
	var yBarTickCount = util.round(maxYBar, yBarFraction) / yBarFraction;
	var yLineTickCount = util.round(maxYLine, yLineFraction) / yLineFraction;
	var tickCount = this.tickCount = Math.max(yBarTickCount, yLineTickCount);
	var yBarDomain = [];
	yBarDomain[0] = 0;
	yBarDomain[1] = yBarFraction * tickCount;
	var yLineDomain = [];
	yLineDomain[0] = 0;
	yLineDomain[1] = yLineFraction * tickCount;
	var x = this.x = d3.scale.ordinal().rangeRoundBands([0, chartDimension.width], barPaddingFraction);
	var yBar = this.yBar = d3.scale.linear().range([chartDimension.height, 0]);
	var yLine = this.yLine = d3.scale.linear().range([chartDimension.height, 0]);
	var monthParser = this.monthParser = d3.time.format("%m");
	var monthFormat = this.monthFormat = d3.time.format("%b");
	var percentFormat = this.percentFormat = d3.format(".2%");
	var xTickCount = 1;
	this.xAxis = d3.svg.axis().scale(this.x).orient("bottom").ticks(0).tickSize(0).tickPadding(8).tickFormat(function(d) {
		if (xTickCount <= data.length) {
			var date = monthParser.parse(d);
			xTickCount++;
			return monthFormat(date)
		} else {
			return ""
		}
	});
	this.yAxisBar = d3.svg.axis().scale(this.yBar).orient("left").ticks(0).tickFormat(d3.format("s"));
	var xDomain = data.map(function(d) {
		return d.key
	});
	if (options.minDataCount && options.minDataCount > data.length) {
		for (var i = 0; i < options.minDataCount - data.length; i++) {
			xDomain.push(parseInt(maxKey) + i)
		}
	}
	x.domain(xDomain);
	if (this.options.max) {
		yBar.domain([0, this.options.max])
	} else {
		yBar.domain(yBarDomain)
	}
	yLine.domain(yLineDomain)
};
BarWithPercentLineChart.prototype.draw = function() {
	var self = this;
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueLine = this.valueLine;
	var data = this.data;
	var chartKey = this.chartKey;
	var yKey = chartKey.y;
	var xKey = chartKey.x;
	var color = this.options.color;
	var tickCount = this.tickCount;
	var barGapRatio = .4;
	var options = this.options;
	var monthParser = this.monthParser;
	var monthFormat = this.monthFormat;
	var percentFormat = this.percentFormat;
	var barColor = this.barColor;
	var lineColor = this.lineColor;
	var svg = this.svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var barWidth = this.x.rangeBand();
	var yGrid = svg.append("g").attr("class", "grid");
	yGrid.call(d3.svg.axis().scale(this.yBar).orient("left").ticks(tickCount).tickSize(-chartWidth, 0, 0).tickFormat(d3.format("s")));
	yGrid.selectAll("text").attr("class", "label");
	var rightYGridLabel = svg.append("g");
	rightYGridLabel.call(d3.svg.axis().scale(this.yLine).orient("right").ticks(tickCount).tickSize(0, 0, 0).tickPadding(chartWidth + 3).tickFormat(d3.format(".2%")));
	rightYGridLabel.selectAll("text").attr("class", "label");
	if (!options.disableXAxisLabel) {
		var xAxis = svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chartHeight + ")").call(this.xAxis);
		xAxis.selectAll("text").attr("class", "label")
	}
	svg.selectAll(".bar1").data(data).enter().append("rect").attr("class", "bar").attr("x", function(d) {
		return self.x(d.key)
	}).attr("width", self.x.rangeBand()).attr("y", function(d) {
		return self.yBar(d.value[yKey.bar])
	}).attr("height", function(d) {
		return chartHeight - self.yBar(d.value[yKey.bar])
	}).attr("fill", barColor).on("mouseover", function(d) {
		var str = d[xKey] + " " + monthFormat(monthParser.parse(d.key)) + " " + d3.format(".3s")(d.value[yKey.bar]);
		util.tooltip.show(d3.event, str, {
			border : barColor
		})
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event)
	});
	var maxKey = this.maxKey;
	var minKey = this.minKey;
	var maxProperty = {};
	maxProperty[xKey] = maxKey;
	var lastData = _.findWhere(data, maxProperty);
	var minProperty = {};
	minProperty[xKey] = minKey;
	var firstData = _.findWhere(data, minProperty);
	svg.append("text").attr("class", "label").attr("text-anchor", "middle").attr("x", self.x(lastData.key) + barWidth / 2).attr("y", self.yBar(lastData.value[yKey.bar])).attr("dy", "-.3em").text(d3.format(".3s")(lastData.value[yKey.bar]));
	var valueLine = d3.svg.line().x(function(d) {
		return self.x(d[xKey]) + barWidth / 2
	}).y(function(d) {
		return self.yLine(d.value[yKey.line])
	});
	svg.append("path").attr("d", valueLine(data)).attr("stroke-width", 2).attr("fill", "none").style("stroke", lineColor);
	var dotLayer = svg.append("g").selectAll("dot").data(data).enter().append("g");
	dotLayer.append("circle").attr("r", 5).attr("cx", function(d) {
		return self.x(d[xKey]) + barWidth / 2
	}).attr("cy", function(d) {
		return self.yLine(d.value[yKey.line])
	}).style("opacity", "0").style("fill", "#000").on("mouseover", function(d, i) {
		$(this).css("opacity", "1");
		var str = monthFormat(monthParser.parse(d[xKey])) + " " + d3.format(".2%")(d.value[yKey.line]);
		util.tooltip.show(d3.event, str, {
			border : lineColor
		})
	}).on("mousemove", function(d, i) {
		$(this).css("opacity", "1");
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).css("opacity", "0");
		util.tooltip.hide(d3.event)
	});
	svg.append("text").attr("class", "gen-label").attr("fill", lineColor).attr("text-anchor", "left").attr("x", self.x(lastData.key) + barWidth / 2).attr("y", self.yLine(lastData.value[yKey.line])).attr("dx", ".3em").attr("dy", ".4em").text(d3.format(".2%")(lastData.value[yKey.line]));
	if (options.showLegend) {
		var cYOfLegend = chartHeight + 10;
		if (options.disableXAxisLabel) {
			cYOfLegend = chartHeight - 10
		}
		var legend = svg.append("g").attr("transform", "translate(0, " + cYOfLegend + ")");
		var legendItemLayer = legend.append("g");
		legendItemLayer.append("rect").attr("x", "0").attr("y", "20").attr("width", "8").attr("height", "8").attr("fill", barColor);
		legendItemLayer.append("text").attr("x", "15").attr("y", "20").attr("dy", ".8em").attr("class", "label").text(self.barLegendText);
		legendItemLayer.append("line").attr("class", "legend-line").attr("x1", "0").attr("y1", "40").attr("x2", "8").attr("y2", "40").attr("stroke-width", 2).style("stroke", lineColor);
		legendItemLayer.append("text").attr("x", "15").attr("y", "40").attr("dy", ".35em").attr("class", "label").text(self.lineLegendText);
		cYOfLegend += 20
	}
};
BarWithPercentLineChart.prototype.update = function() {
};
var TwoSideBarWithPercentLineChart = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el || "body";
	var minYBarDomainUpperValue = .01;
	var minYLineDomainUpperValue = 1;
	var barPaddingFraction = .2;
	this.lineColor = chartKey.subjectName ? util.color(chartKey.subjectName) : "SteelBlue";
	this.lineLegendText = "Weekly Talks";
	var minWidth = 200;
	var minHeight = 100;
	var defaultDimension = {
		width : 280,
		height : 120
	};
	var defaultMargin = {
		top : 20,
		right : 80,
		bottom : 20,
		left : 40
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	};
	data.sort(function(a, b) {
		var numA = parseInt(a[chartKey.x]);
		var numB = parseInt(b[chartKey.x]);
		if (numA > numB) {
			return 1
		} else if (numA < numB) {
			return -1
		} else {
			return 0
		}
	});
	var xKey = chartKey.x;
	var maxKey = this.maxKey = d3.max(data, function(d) {
		return d[xKey]
	});
	var minKey = this.minKey = d3.min(data, function(d) {
		return d[xKey]
	});
	var yKey = chartKey.y;
	var xKey = chartKey.x;
	var barDataDomain = d3.extent(data, function(d) {
		return d.value[yKey.bar]
	});
	var lineDataDomain = d3.extent(data, function(d) {
		return d.value[yKey.line]
	});
	var minYBar = this.minYBar = barDataDomain[0];
	var maxYBar = this.maxYBar = barDataDomain[1];
	var absMaxYBar = Math.max(Math.abs(minYBar), Math.abs(maxYBar));
	if (absMaxYBar === 0) {
		absMaxYBar = minYBarDomainUpperValue
	}
	var yBarFraction = util.getMostDec(absMaxYBar) * 5;
	var maxYLine = this.maxYLine = lineDataDomain[1];
	if (maxYLine === 0) {
		maxYLine = minYLineDomainUpperValue
	}
	var yLineFraction = util.getMostDec(maxYLine) * 2;
	var tickCount = this.tickCount = 2;
	var yBarDomain = [];
	var yBarDomainUpperValue = util.round(absMaxYBar, yBarFraction);
	yBarDomain[0] = -yBarDomainUpperValue;
	yBarDomain[1] = yBarDomainUpperValue;
	var yLineDomain = this.yLineDomain = [];
	var yLineDomainUpperValue = util.round(maxYLine, yLineFraction);
	yLineDomain[0] = -yLineDomainUpperValue;
	yLineDomain[1] = yLineDomainUpperValue;
	var x = this.x = d3.scale.ordinal().rangeRoundBands([0, chartDimension.width], barPaddingFraction);
	var yBar = this.yBar = d3.scale.linear().range([chartDimension.height, 0]);
	var yLine = this.yLine = d3.scale.linear().range([chartDimension.height, 0]);
	var weekFormat = this.weekFormat = d3.time.format("%d-%b");
	var xTickCount = 0;
	this.xAxis = d3.svg.axis().scale(this.x).orient("bottom").ticks(0).tickSize(0).tickPadding(8).tickFormat(function(d) {
		if (xTickCount % 4 === 0 && xTickCount < data.length) {
			xTickCount++;
			var mDate = moment().week(d).year(window.currentStartDate.getFullYear());
			var firstWeekDay = mDate.startOf("week").toDate();
			return weekFormat(firstWeekDay)
		} else {
			xTickCount++
		}
	});
	var xDomain = data.map(function(d) {
		return d.key
	});
	if (options.minDataCount && options.minDataCount > data.length) {
		for (var i = 0; i < options.minDataCount - data.length; i++) {
			xDomain.push(maxKey + i)
		}
	}
	x.domain(xDomain);
	if (this.options.max) {
		yBar.domain([0, this.options.max])
	} else {
		yBar.domain(yBarDomain)
	}
	yLine.domain(yLineDomain)
};
TwoSideBarWithPercentLineChart.prototype.draw = function() {
	var self = this;
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueLine = this.valueLine;
	var data = this.data;
	var chartKey = this.chartKey;
	var yKey = chartKey.y;
	var xKey = chartKey.x;
	var color = this.options.color;
	var tickCount = this.tickCount;
	var barGapRatio = .1;
	var yLineDomain = this.yLineDomain;
	var options = this.options;
	var weekFormat = this.weekFormat;
	var lineColor = this.lineColor;
	var svg = this.svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var barWidth = this.x.rangeBand();
	var yGrid = svg.append("g").attr("class", "grid");
	yGrid.call(d3.svg.axis().scale(this.yBar).orient("left").ticks(tickCount).tickSize(-chartWidth, 0, 0).tickFormat(d3.format("%")));
	yGrid.selectAll("text").attr("class", "label");
	var rightYGridLabel = svg.append("g").attr("class", "grid-right-label");
	rightYGridLabel.append("text").attr("x", chartWidth + 3).attr("y", chartHeight).attr("dy", ".24em").text(d3.format("s")(yLineDomain[0]));
	rightYGridLabel.append("text").attr("x", chartWidth + 3).attr("y", chartHeight / 2).attr("dy", ".24em").text(d3.format("s")(0));
	rightYGridLabel.append("text").attr("x", chartWidth + 3).attr("y", 0).attr("dy", ".24em").text(d3.format("s")(yLineDomain[1]));
	rightYGridLabel.selectAll("text").attr("class", "label");
	if (!options.disableXAxisLabel) {
		var xAxis = svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chartHeight + ")").call(this.xAxis);
		xAxis.selectAll("text").attr("class", "label")
	}
	var barGroup = svg.selectAll(".bar").data(data).enter().append("g");
	barGroup.append("rect").attr("class", function(d) {
		return d.value[yKey.bar] >= 0 ? "bar positive" : "bar negative"
	}).attr("x", function(d, i) {
		return self.x(d.key)
	}).attr("y", function(d, i) {
		return self.yBar(Math.max(0, d.value[yKey.bar]))
	}).attr("width", self.x.rangeBand()).attr("height", function(d) {
		return Math.abs(self.yBar(d.value[yKey.bar]) - self.yBar(0))
	}).style("fill", function(d) {
		return d.value[yKey.bar] >= 0 ? "#9bbb59" : "#f79646"
	}).on("mouseover", function(d, i) {
		var mDate = moment().week(d[xKey]).year(window.currentStartDate.getFullYear());
		var firstWeekDay = mDate.startOf("week").toDate();
		var lastWeekDay = mDate.clone().endOf("week").toDate();
		var str = weekFormat(firstWeekDay) + " - " + weekFormat(lastWeekDay) + " " + d3.format(".2%")(d.value[yKey.bar]);
		util.tooltip.show(d3.event, str, {
			border : d.value[yKey.bar] >= 0 ? "#9bbb59" : "#f79646"
		})
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event)
	});
	var valueLine = d3.svg.line().x(function(d) {
		return self.x(d[xKey]) + barWidth / 2
	}).y(function(d) {
		return self.yLine(d.value[yKey.line])
	});
	svg.append("path").attr("d", valueLine(data)).attr("stroke-width", 2).attr("fill", "none").style("stroke", lineColor);
	var dotLayer = svg.append("g").selectAll("dot").data(data).enter().append("g");
	dotLayer.append("circle").attr("r", 5).attr("cx", function(d) {
		return self.x(d[xKey]) + barWidth / 2
	}).attr("cy", function(d) {
		return self.yLine(d.value[yKey.line])
	}).style("opacity", "0").style("fill", lineColor).on("mouseover", function(d, i) {
		$(this).css("opacity", "1");
		var mDate = moment().week(d[xKey]).year(window.currentStartDate.getFullYear());
		var firstWeekDay = mDate.startOf("week").toDate();
		var lastWeekDay = mDate.clone().endOf("week").toDate();
		var str = weekFormat(firstWeekDay) + " - " + weekFormat(lastWeekDay) + " " + d3.format(".3s")(d.value[yKey.line]);
		util.tooltip.show(d3.event, str, {
			border : lineColor
		})
	}).on("mousemove", function(d, i) {
		$(this).css("opacity", "1");
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).css("opacity", "0");
		util.tooltip.hide(d3.event)
	});
	if (options.showLegend) {
		var cYOfLegend = chartHeight + 10;
		if (options.disableXAxisLabel) {
			cYOfLegend = chartHeight - 5
		}
		var legend = svg.append("g").attr("transform", "translate(0, " + cYOfLegend + ")");
		var legendItemLayer = legend.append("g");
		legendItemLayer.append("line").attr("class", "legend-line").attr("x1", "0").attr("y1", "20").attr("x2", "8").attr("y2", "20").attr("stroke-width", 2).style("stroke", lineColor);
		legendItemLayer.append("text").attr("x", "15").attr("y", "20").attr("dy", ".35em").attr("class", "label").text(self.lineLegendText)
	}
};
TwoSideBarWithPercentLineChart.prototype.update = function() {
};
var numberFormat = d3.format(",.1f");
var formatPercent = d3.format(".0%");
var formatPercent1 = d3.format(".01%");
var intFormat = d3.format(",");
var labelMargin = 5;
var RankingBar = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el;
	var minWidth = 250;
	var minHeight = 220;
	var defaultDimension = {
		width : 250,
		height : 220
	};
	var defaultMargin = {
		top : 10,
		right : 10,
		bottom : 20,
		left : 100
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	}
};
RankingBar.prototype.draw = function() {
	var margin = this.margin, width = this.dimension.width, height = this.dimension.height, data = this.data, chartKey = this.chartKey, myColor = typeof this.options.color === "undefined" ? "#d9d9d9" : this.options.color;
	var authorWidth = this.options.authorWidth ? this.options.authorWidth : 200;
	var _max = d3.max(data, function(d) {
		return d.value[chartKey.data]
	});
	var max = this.options.max ? this.options.max : _max;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueMode = this.options.valueMode ? this.options.valueMode : "number";
	var showTopLabel = typeof this.options.showTopLabel === "undefined" ? false : this.options.showTopLabel;
	if (valueMode.toLowerCase() == "percent") {
		var RankingBarFormat = d3.format(".1%");
		var axisFormat = d3.format(".0%")
	} else {
		var RankingBarFormat = d3.format(",");
		var axisFormat = d3.format(".1s")
	}
	var x = d3.scale.linear().domain([0, max]).range([0, chartWidth]);
	var y = d3.scale.ordinal().domain(data.map(function(d) {
		return d.key
	})).rangeRoundBands([0, chartHeight], .3, 0);
	function make_x_axis() {
		return d3.svg.axis().scale(x).orient("bottom").ticks(5).tickFormat(axisFormat)
	}

	var svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).attr("class", "horizontal bar").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var barGroup = svg.selectAll(".bar").data(data).enter().append("g");
	barGroup.append("rect").attr("class", "bar").attr("x", 0).attr("y", function(d) {
		return y(d.key)
	}).attr("width", function(d) {
		return x(d.value[chartKey.data])
	}).attr("height", y.rangeBand()).style("fill", myColor).on("mouseover", function(d) {
		var s = util.displayName(d.key.split("|")[0]) + " " + util.displayName(d.key.split("|")[1]) + " " + RankingBarFormat(d.value[chartKey.data]);
		util.tooltip.show(d3.event, s, {
			border : myColor
		})
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event)
	});
	barGroup.append("text").attr("class", "label").attr("dy", ".7em").attr("transform", function(d) {
		return "translate(" + chartWidth + "," + y(d.key) + ")"
	}).style("text-anchor", "end").text(function(d) {
		return RankingBarFormat(d.value[chartKey.data])
	});
	barGroup.append("text").attr("class", "label").attr("dy", ".7em").attr("transform", function(d) {
		return "translate(" + (chartWidth + 7) + "," + y(d.key) + ")"
	}).style("text-anchor", "start").text(function(d) {
		return util.trimLabel(util.displayName(d.key.split("|")[0]))
	});
	barGroup.append("text").attr("class", "label").attr("dy", ".7em").attr("transform", function(d) {
		return "translate(" + (chartWidth + 7 + authorWidth) + "," + y(d.key) + ")"
	}).style("text-anchor", "start").text(function(d) {
		return util.trimLabel(util.displayName(d.key.split("|")[1]))
	});
	if (showTopLabel) {
		var topGroup = svg.append("g").attr("class", "top");
		var halfSpace = (y(data[1].key) - y(data[0].key)) / 2 * .3;
		topGroup.append("line").attr("x1", -margin.left).attr("x2", width + margin.right).attr("y1", y(data[5].key) - halfSpace).attr("y2", y(data[5].key) - halfSpace);
		topGroup.append("line").attr("x1", -margin.left).attr("x2", width + margin.right).attr("y1", y(data[10].key) - halfSpace).attr("y2", y(data[10].key) - halfSpace);
		topGroup.append("text").attr("transform", function() {
			return "translate(-10," + (y(data[10].key) - 2 * halfSpace) + ")rotate(-90)"
		}).attr("class", "label").style("fill", myColor).text("Top 10");
		topGroup.append("text").attr("transform", function() {
			return "translate(-10," + (y(data[5].key) - 2 * halfSpace) + ")rotate(-90)"
		}).attr("class", "label").style("fill", myColor).text("Top 5")
	}
	svg.append("g").attr("class", "y axis").append("line").attr("x1", x(0)).attr("x2", x(0)).attr("y2", chartHeight)
};
var animationDurationForBar = 700;
var BarChart = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el || "body";
	var minWidth = 45;
	var minHeight = 20;
	var defaultDimension = {
		width : 45,
		height : 20
	};
	var defaultMargin = {
		top : 0,
		right : 0,
		bottom : 0,
		left : 0
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth;
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight;
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	};
	var x = this.x = d3.time.scale().range([0, chartDimension.width]);
	var y = this.y = d3.scale.linear().range([chartDimension.height, 0]);
	this.xAxis = d3.svg.axis().scale(this.x).orient("bottom").ticks(0).tickFormat(d3.time.format("%e %b"));
	this.yAxis = d3.svg.axis().scale(this.y).orient("left").ticks(0);
	var xDomain = d3.extent(data, function(d) {
		return d[chartKey.x];
	});
	x.domain(xDomain);
	var yKey = chartKey.y;
	var yRawDomain = [];
	for (var i = 0; i < yKey.length; i++) {
		yRawDomain = yRawDomain.concat(d3.extent(data, function(d) {
			return d.value[yKey[i]];
		}));
	}
	var yDomain = d3.extent(yRawDomain, function(d) {
		return d;
	});
	if (this.options.max) {
		y.domain([0, this.options.max]);
	} else {
		y.domain(yRawDomain);
	}
};
BarChart.prototype.draw = function(object) {
	var self = this;
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueLine = this.valueLine;
	var data = this.data;
	var chartKey = this.chartKey;
	var yKey = chartKey.y;
	var color = this.options.color;
	var maxDate = _.max(this.data,function(row){return row[chartKey.x];})[chartKey.x];
	var minDate = _.min(this.data,function(row){return row[chartKey.x];})[chartKey.x];
	var svg = this.svg = d3.select(this.el).append("svg").attr("width", "100%").attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var barWidth = chartWidth / data.length;
	for (var i = 0; i < yKey.length; i++) {
		svg.selectAll(".bar1").data(data).enter().append("rect").attr("class", "bar talks").attr("x", function(d) {
			return self.x(d.key);
		}).attr("width", barWidth).attr("y", function(d) {
			return self.y(d.value[yKey[i]])
		}).attr("height", function(d) {
			return chartHeight - self.y(d.value[yKey[i]])
		}).attr("fill", "SteelBlue")
		.style("cursor", "pointer").on("click", function(d) {
			object.onClick(d);
		});
		if (!disableAnimation || typeof disableAnimation == "undefined") {
			animatedBar = d3.selectAll("rect.bar.talks");
			animatedBar.attr("y", self.y(0)).attr("height", 0).transition().duration(animationDurationForBar).ease("quad").attr("y", function(d) {
				return self.y(d.value[yKey[i]])
			}).attr("height", function(d) {
				return chartHeight - self.y(d.value[yKey[i]])
			})
		}
	}
};
BarChart.prototype.update = function() {
};
var BarWithLineChart = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el || "body";
	var minWidth = 150;
	var minHeight = 80;
	var defaultDimension = {
		width : 240,
		height : 120
	};
	var defaultMargin = {
		top : 10,
		right : 30,
		bottom : 20,
		left : 40
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	};
	var x = this.x = d3.scale.ordinal().rangeBands([0, chartDimension.width], .4);
	var y = this.y = d3.scale.linear().range([chartDimension.height, 0]);
	this.xAxis = d3.svg.axis().scale(x).orient("bottom").tickFormat("").innerTickSize(0);
	this.yAxis = d3.svg.axis().scale(y).orient("left").ticks(0);
	var xDomain = d3.extent(data, function(d) {
		return d[chartKey.x]
	});
	x.domain(_.map(data, function(d) {
		return d[chartKey.x]
	}));
	var yKey = chartKey.y;
	var yRawDomain = [];
	for (var i = 0; i < yKey.length; i++) {
		yRawDomain = yRawDomain.concat(d3.extent(data, function(d) {
			return d.value[yKey[i]]
		}))
	}
	var yDomain = d3.extent(yRawDomain, function(d) {
		return d
	});
	y.domain([0, yDomain[1]])
};
BarWithLineChart.prototype.draw = function() {
	var self = this;
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueLine = this.valueLine;
	var data = this.data;
	var chartKey = this.chartKey;
	var yKey = chartKey.y;
	var xKey = chartKey.x;
	var color = this.options.color;
	var maxDate = _.max(this.data,function(row){return row[chartKey.x]})[chartKey.x];
	var minDate = _.min(this.data,function(row){return row[chartKey.x]})[chartKey.x];
	var svg = this.svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	svg.append("g").attr("class", "grid").call(d3.svg.axis().scale(this.y).orient("left").ticks(5).tickSize(-chartWidth, 0, 0).tickFormat(""));
	for (var i = 0; i < yKey.length; i++) {
		svg.append("g").selectAll(".bar").data(data).enter().append("rect").attr("class", "bar").attr("x", function(d, i) {
			return self.x(d[xKey])
		}).attr("width", self.x.rangeBand()).attr("y", function(d) {
			return self.y(d.value[yKey[i]])
		}).attr("height", function(d) {
			return chartHeight - self.y(d.value[yKey[i]])
		}).attr("fill", "SteelBlue");
		var valueLine = d3.svg.line().interpolate("bundle").x(function(d) {
			return self.x(d[chartKey.x]) + self.x.rangeBand() / 2
		}).y(function(d) {
			return self.y(d.value[yKey[i]])
		});
		svg.append("path").attr("d", valueLine(data)).attr("stroke-width", 2).attr("fill", "none").attr("stroke", "#999")
	}
	var xAxis = svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chartHeight + ")").call(this.xAxis);
	var yAxis = svg.append("g").attr("class", "y axis").call(this.yAxis);
	yAxis.append("text").text("High").attr("transform", "translate(-9,0)").attr("dy", ".32em").style("text-anchor", "end").attr("class", "label");
	yAxis.append("text").text("Low").attr("transform", "translate(-9," + chartHeight + ")").attr("dy", ".32em").style("text-anchor", "end").attr("class", "label");
	xAxis.append("text").text(d3.time.format("%e %b")(minDate)).attr("x", 0).attr("y", 9).attr("dy", ".71em").style("text-anchor", "middle").attr("class", "label");
	xAxis.append("text").text(d3.time.format("%e %b")(maxDate)).attr("x", chartWidth).attr("y", 9).attr("dy", ".71em").style("text-anchor", "middle").attr("class", "label");
	svg.append("text").attr("transform", "rotate(-90)").attr("x", 0 - chartHeight / 2).attr("y", 0).attr("dy", "-1.5em").style("text-anchor", "middle").text("Talk").attr("class", "label");
	svg.append("text").attr("x", width / 2).attr("y", height).attr("dy", "1.5em").style("text-anchor", "middle").text("Date").attr("class", "label");
	var lastData = data[data.length-1].value[yKey[0]];
	svg.append("text").attr("x", width + 2).attr("y", this.y(lastData)).attr("dy", ".32em").style("text-anchor", "left").text(lastData).attr("fill", "#999").attr("class", "label")
};
BarWithLineChart.prototype.update = function() {
};
var numberFormat = d3.format(",.3s");
var formatPercent = d3.format(".1%");
var formatPercent1 = d3.format(".01%");
var intFormat = d3.format(",");
var labelMargin = 5;
var animationDuration = 700;
var SentimentBar = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el;
	var minWidth = 240;
	var minHeight = 50;
	var defaultDimension = {
		width : 300,
		height : 180
	};
	var defaultMargin = {
		top : 1,
		right : 1,
		bottom : 1,
		left : 1
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth;
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight;
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	};
};
SentimentBar.prototype.draw = function(object) {
	var margin = this.margin, width = this.dimension.width, height = this.dimension.height, data = this.data, myChartKey = this.chartKey;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var showYGrid = typeof this.options.showYGrid === "undefined" ? true : this.options.showYGrid;
	var showLabel = typeof this.options.showLabel === "undefined" ? false : this.options.showLabel;
	var showRectLabel = typeof this.options.showRectLabel === "undefined" ? false : this.options.showRectLabel;
	var valueMode = this.options.valueMode ? this.options.valueMode.toLowerCase() : "number";
	var showNumber = typeof this.options.showNumber === "undefined" ? true : this.options.showNumber;
	var showXAxis = typeof this.options.showXAxis === "undefined" ? true : this.options.showXAxis;
	var showLegend = typeof this.options.showLegend === "undefined" ? false : this.options.showLegend;
	if ( typeof this.options.subject !== "undefined")
		var subject = this.options.subject;
	if ( typeof this.options.channel !== "undefined")
		var channel = this.options.channel;
	if ( typeof this.options.otherSubjectArray !== "undefined")
		var otherSubjectArray = this.options.otherSubjectArray;
	var interestedChartkey = {
		prev_negative : "",
		current_negative : "",
		prev_positive : "",
		current_positive : ""
	};
	if (valueMode == "percent") {
		var sentimentNumberFormat = d3.format(".1%");
		interestedChartkey.prev_negative = myChartKey.prev_negative_percent;
		interestedChartkey.current_negative = myChartKey.current_negative_percent;
		interestedChartkey.prev_positive = myChartKey.prev_positive_percent;
		interestedChartkey.current_positive = myChartKey.current_positive_percent;
	} else {
		var sentimentNumberFormat = d3.format(",.3s");
		interestedChartkey.prev_negative = myChartKey.prev_negative;
		interestedChartkey.current_negative = myChartKey.current_negative;
		interestedChartkey.prev_positive = myChartKey.prev_positive;
		interestedChartkey.current_positive = myChartKey.current_positive;
	}
	var max = Math.max(Math.abs(d3.max(data, function(d) {
		return d.value[interestedChartkey.prev_negative];
	})), Math.abs(d3.max(data, function(d) {
		return d.value[interestedChartkey.current_negative];
	})), Math.abs(d3.max(data, function(d) {
		return d.value[interestedChartkey.prev_positive];
	})), Math.abs(d3.max(data, function(d) {
		return d.value[interestedChartkey.current_positive];
	})));
	max *= 100;
	if (max < 10)
		max = 10;
	else
		max = 5 * Math.ceil(max / 5);
	max /= 100;
	var x = d3.scale.linear().domain([-max, max]).range([0, chartWidth]);
	var yTemp = d3.scale.ordinal().domain(data.map(function(d) {
		return d.key;
	})).rangeRoundBands([0, chartHeight], .7, 0);
	if (data.length > 1)
		var paddingBottom = (yTemp(data[1].key) - yTemp(data[0].key) - yTemp.rangeBand() * 2 - 2) / 2 + yTemp.rangeBand();
	else
		var paddingBottom = yTemp.rangeBand() / 2 + 10;
	var y = d3.scale.ordinal().domain(data.map(function(d) {
		return d.key;
	})).rangeRoundBands([0, chartHeight - paddingBottom], .7, 0);
	function make_x_axis() {
		return d3.svg.axis().scale(x).orient("bottom").ticks(0).tickFormat("");
	}

	var svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).attr("class", "sentiment bar").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	svg.append("g").attr("class", "grid").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis().ticks(10).tickSize(-chartHeight, 0, 0).tickFormat(""));
	var barGroup = svg.selectAll(".bar").data(data).enter().append("g");
	var maxbarHeight = 20;
	var barHeight = y.rangeBand() > maxbarHeight ? maxbarHeight : y.rangeBand();
	var y1 = chartHeight / data.length;
	var y2 = y1 / 2 + barHeight;
	var animatedBar;
	barGroup.append("rect").attr("class", "bar previous negative").attr("x", function(d) {
		return x(Math.min(0, -d.value[interestedChartkey.prev_negative]));
	}).attr("y", function(d, i) {
		return y1 * (i + 1) - y2
	}).attr("width", function(d) {
		return Math.abs(x(d.value[interestedChartkey.prev_negative]) - x(0));
	}).attr("height", barHeight).style("fill", function(d) {
		return util.color("negative");
	}).on("mouseover", function(d) {
		var s = util.displayName(d.key) + " (Previous Period) " + sentimentNumberFormat(d.value[interestedChartkey.prev_negative]);
		if (valueMode == "percent")
			s += " (" + numberFormat(d.value[myChartKey.prev_negative]) + ")";
		util.tooltip.show(d3.event, s, {
			border : util.color("negative", "border")
		});
		$(this).attr("style", "fill: " + util.color("negative", "hover") + "; cursor: pointer;");
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event);
	}).on("mouseout", function(d, i) {
		$(this).attr("style", "fill: " + util.color("negative") + "; cursor: pointer;");
		util.tooltip.hide(d3.event);
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key
		// } else {
			// var subjectToFetch = otherSubjectArray
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof channel !== "undefined" ? channel : typeof subject !== "undefined" ? d.key : null,
			// sentiment : -1,
			// from : window.previousStartDate.getFullYear() + "-" + parseInt(parseInt(window.previousStartDate.getMonth()) + 1) + "-" + window.previousStartDate.getDate(),
			// to : window.previousEndDate.getFullYear() + "-" + parseInt(parseInt(window.previousEndDate.getMonth()) + 1) + "-" + window.previousEndDate.getDate(),
			// talk : d.value[myChartKey.prev_negative]
		// };
		// util.getPost(conditions)
		d.time = 'past';
		d.data = {};
		d.data.group_id = d.group_id;
		d.data.sentiment = ['neg'];
		object.onClick(d);
	});
	if (!disableAnimation || typeof disableAnimation == "undefined") {
		animatedBar = d3.selectAll("rect.bar.previous.negative");
		animatedBar.attr("width", 0).attr("x", x(0)).attr("stroke-width", 4).attr("height", barHeight).transition().duration(animationDuration).ease("quad").attr("width", function(d) {
			return Math.abs(x(d.value[interestedChartkey.prev_negative]) - x(0));
		}).attr("x", function(d) {
			return x(Math.min(0, -d.value[interestedChartkey.prev_negative]));
		});
	}
	if (showNumber) {
		barGroup.append("text").attr("class", "mini label").attr("dy", barHeight / 2 + 3).attr("transform", function(d, i) {
			return "translate(" + (x(-d.value[interestedChartkey.prev_negative]) - labelMargin) + "," + (y1 * (i + 1) - y2) + ")"
		}).text(function(d) {
			return sentimentNumberFormat(-d.value[interestedChartkey.prev_negative])
		}).style("text-anchor", "end").style("fill", "#f79646")
	}
	barGroup.append("rect").attr("class", "bar previous positive").attr("x", function(d) {
		return x(Math.min(0, d.value[interestedChartkey.prev_positive]))
	}).attr("y", function(d, i) {
		return y1 * (i + 1) - y2
	}).attr("width", function(d) {
		return Math.abs(x(d.value[interestedChartkey.prev_positive]) - x(0))
	}).attr("height", barHeight).style("fill", function(d) {
		return util.color("positive")
	}).on("mouseover", function(d) {
		var s = util.displayName(d.key) + " (Previous Period) " + sentimentNumberFormat(d.value[interestedChartkey.prev_positive]);
		if (valueMode == "percent")
			s += " (" + numberFormat(d.value[myChartKey.prev_positive]) + ")";
		util.tooltip.show(d3.event, s, {
			border : util.color("positive", "border")
		});
		$(this).attr("style", "fill: " + util.color("positive", "hover") + "; cursor: pointer;")
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).attr("style", "fill: " + util.color("positive") + "; cursor: pointer;");
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key
		// } else {
			// var subjectToFetch = otherSubjectArray
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof channel !== "undefined" ? channel : typeof subject !== "undefined" ? d.key : null,
			// sentiment : 1,
			// from : window.previousStartDate.getFullYear() + "-" + parseInt(parseInt(window.previousStartDate.getMonth()) + 1) + "-" + window.previousStartDate.getDate(),
			// to : window.previousEndDate.getFullYear() + "-" + parseInt(parseInt(window.previousEndDate.getMonth()) + 1) + "-" + window.previousEndDate.getDate(),
			// talk : d.value[myChartKey.prev_positive]
		// };
		// util.getPost(conditions)
		
		d.time = 'past';
		d.data = {};
		d.data.group_id = d.group_id;
		d.data.sentiment = ['pos'];
		object.onClick(d);
	});
	if (!disableAnimation || typeof disableAnimation == "undefined") {
		animatedBar = d3.selectAll("rect.bar.previous.positive");
		animatedBar.attr("width", 0).attr("stroke-width", 4).attr("height", barHeight).transition().duration(animationDuration).ease("quad").attr("width", function(d) {
			return Math.abs(x(d.value[interestedChartkey.prev_positive]) - x(0))
		})
	}
	if (showNumber) {
		barGroup.append("text").attr("class", "mini label").attr("dy", barHeight / 2 + 3).attr("transform", function(d, i) {
			return "translate(" + (x(d.value[interestedChartkey.prev_positive]) + 5) + "," + (y1 * (i + 1) - y2) + ")"
		}).text(function(d) {
			return sentimentNumberFormat(d.value[interestedChartkey.prev_positive])
		}).style("fill", "#9bbb59")
	}
	barGroup.append("rect").attr("class", "bar current negative").attr("x", function(d) {
		return x(Math.min(0, -d.value[interestedChartkey.current_negative]))
	}).attr("y", function(d, i) {
		return y1 * (i + 1) - y2 + barHeight
	}).attr("width", function(d) {
		return Math.abs(x(d.value[interestedChartkey.current_negative]) - x(0))
	}).attr("height", barHeight).style("fill", function(d) {
		return util.color("negative")
	}).on("mouseover", function(d) {
		if (valueMode == "percent")
			var s = util.displayName(d.key) + " " + sentimentNumberFormat(d.value[interestedChartkey.current_negative]) + " (" + numberFormat(d.value[myChartKey.current_negative]) + ")";
		else
			var s = util.displayName(d.key) + " " + sentimentNumberFormat(d.value[interestedChartkey.current_negative]);
		s += util.showChange(util.displayName(d.key), d.value[myChartKey.negative_change], d.value[myChartKey.negative_change_percent], d.value[myChartKey.negative_percent_change], valueMode);
		util.tooltip.show(d3.event, s, {
			border : util.color("negative", "border")
		});
		$(this).attr("style", "fill: " + util.color("negative", "hover") + "; cursor: pointer;")
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).attr("style", "fill: " + util.color("negative") + "; cursor: pointer;");
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key
		// } else {
			// var subjectToFetch = otherSubjectArray
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof channel !== "undefined" ? channel : typeof subject !== "undefined" ? d.key : null,
			// sentiment : -1,
			// talk : d.value[myChartKey.current_negative]
		// };
		// util.getPost(conditions)
		
		// negative
		d.time = 'current';
		d.data = {};
		d.data.group_id = d.group_id;
		d.data.sentiment = ['neg'];
		object.onClick(d);
	});
	if (!disableAnimation || typeof disableAnimation == "undefined") {
		animatedBar = d3.selectAll("rect.bar.current.negative");
		animatedBar.attr("width", 0).attr("x", x(0)).attr("stroke-width", 4).attr("height", barHeight).transition().duration(animationDuration).ease("quad").attr("width", function(d) {
			return Math.abs(x(d.value[interestedChartkey.current_negative]) - x(0))
		}).attr("x", function(d) {
			return x(Math.min(0, -d.value[interestedChartkey.current_negative]))
		})
	}
	if (showNumber) {
		barGroup.append("text").attr("class", "mini label").attr("dy", barHeight / 2 + 3 + barHeight).attr("transform", function(d, i) {
			return "translate(" + (x(-d.value[interestedChartkey.current_negative]) - labelMargin) + "," + (y1 * (i + 1) - y2) + ")"
		}).text(function(d) {
			return sentimentNumberFormat(-d.value[interestedChartkey.current_negative])
		}).style("text-anchor", "end").style("fill", "#f79646")
	}
	barGroup.append("rect").attr("class", "bar current positive").attr("x", function(d) {
		return x(Math.min(0, d.value[interestedChartkey.current_positive]))
	}).attr("y", function(d, i) {
		return y1 * (i + 1) - y2 + barHeight
	}).attr("width", function(d) {
		return Math.abs(x(d.value[interestedChartkey.current_positive]) - x(0))
	}).attr("height", barHeight).style("fill", function(d) {
		return util.color("positive")
	}).on("mouseover", function(d) {
		if (valueMode == "percent")
			var s = util.displayName(d.key) + " " + sentimentNumberFormat(d.value[interestedChartkey.current_positive]) + " (" + numberFormat(d.value[myChartKey.current_positive]) + ")";
		else
			var s = util.displayName(d.key) + " " + sentimentNumberFormat(d.value[interestedChartkey.current_positive]);
		s += util.showChange(d.key, d.value[myChartKey.positive_change], d.value[myChartKey.positive_change_percent], d.value[myChartKey.positive_percent_change], valueMode);
		util.tooltip.show(d3.event, s, {
			border : util.color("positive", "border")
		});
		$(this).attr("style", "fill: " + util.color("positive", "hover") + "; cursor: pointer;")
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).attr("style", "fill: " + util.color("positive") + "; cursor: pointer;");
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key;
		// } else {
			// var subjectToFetch = otherSubjectArray;
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof channel !== "undefined" ? channel : typeof subject !== "undefined" ? d.key : null,
			// sentiment : 1,
			// talk : d.value[myChartKey.current_positive]
		// };
		// util.getPost(conditions)
		// console.log(d);
		
		// positive
		d.time = 'current';
		d.data = {};
		d.data.group_id = d.group_id;
		d.data.sentiment = ['pos'];
		object.onClick(d);
	});
	if (!disableAnimation || typeof disableAnimation == "undefined") {
		animatedBar = d3.selectAll("rect.bar.current.positive");
		animatedBar.attr("width", 0).attr("stroke-width", 4).attr("height", barHeight).transition().duration(animationDuration).ease("quad").attr("width", function(d) {
			return Math.abs(x(d.value[interestedChartkey.current_positive]) - x(0));
		});
	}
	if (showNumber) {
		barGroup.append("text").attr("class", "mini label").attr("dy", barHeight / 2 + 3 + barHeight).attr("transform", function(d, i) {
			return "translate(" + (x(d.value[interestedChartkey.current_positive]) + 5) + "," + (y1 * (i + 1) - y2) + ")";
		}).text(function(d) {
			return sentimentNumberFormat(d.value[interestedChartkey.current_positive]);
		}).style("fill", "#9bbb59");
	}
	if (showYGrid) {
		barGroup.append("line").attr("class", "grid").attr("x1", -margin.left).attr("y1", function(d, i) {
			return chartHeight / data.length * (i + 1)
		}).attr("x2", chartWidth).attr("y2", function(d, i) {
			return chartHeight / data.length * (i + 1)
		}).style("visibility", function(d, i) {
			if (i == data.length - 1)
				return "hidden";
			else
				return "visible"
		});
		svg.append("line").attr("class", "axis").attr("x1", -margin.left).attr("y1", chartHeight).attr("x2", margin.left).attr("y2", chartHeight)
	}
	if (showLabel) {
		if (showRectLabel) {
			barGroup.append("rect").attr("width", 8).attr("height", 8).attr("class", "previous").attr("transform", function(d, i) {
				return "translate(" + -margin.left + "," + (y1 * (i + 1) - y2 + barHeight - 5) + ")"
			}).style("fill", function(d) {
				return util.color(d.key)
			});
			barGroup.append("rect").attr("width", 8).attr("height", 8).attr("transform", function(d, i) {
				return "translate(" + -(margin.left - 8) + "," + (y1 * (i + 1) - y2 + barHeight - 5) + ")"
			}).style("fill", function(d) {
				return util.color(d.key)
			})
		}
		barGroup.append("text").attr("class", "label").attr("dy", ".7em").attr("transform", function(d, i) {
			return "translate(" + -(margin.left - 18) + "," + (y1 * (i + 1) - y2 + barHeight - 5) + ")"
		}).text(function(d) {
			return util.trimLabel(util.displayName(d.key))
		}).style("fill", function(d) {
			return util.color(d.key)
		})
	}
	if (showXAxis) {
		svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis());
		svg.append("text").attr("class", "label").attr("transform", "translate(-10," + (chartHeight + 15) + ")").text("-" + sentimentNumberFormat(max));
		svg.append("text").attr("class", "label").attr("transform", "translate(" + (chartWidth - 10) + "," + (chartHeight + 15) + ")").text(sentimentNumberFormat(max)).style("text-anchor", "middle");
		svg.append("text").attr("class", "label").attr("transform", "translate(" + (chartWidth / 2 - 5) + "," + (chartHeight + 15) + ")").text(sentimentNumberFormat(0))
	}
	svg.append("g").attr("class", "y axis").append("line").attr("x1", x(0)).attr("x2", x(0)).attr("y2", chartHeight);
	if (showLegend) {
		var xLegend;
		if (this.options.legendPosition.toLowerCase() == "left")
			xLegend = -margin.left;
		else
			xLegend = chartWidth + 20;
		var legendLabel = [{
			name : "Negative",
			rect1 : "#fcd5b5",
			rect2 : "#f79646"
		}, {
			name : "Positive",
			rect1 : "#c3d69b",
			rect2 : "#9bbb59"
		}];
		var legend = svg.append("g").attr("class", "legend").attr("transform", "translate(" + xLegend + "," + (chartHeight - 10) + ")").selectAll("g.label").data(legendLabel).enter().append("g").attr("transform", function(d, i) {
			return "translate(0," + (i + 1) * 10 + ")"
		});
		svg.append("text").text("Previous").attr("transform", "translate(" + xLegend + "," + (chartHeight - 5) + ")rotate(-90)").attr("class", "label").attr("dy", ".7em");
		svg.append("text").text("Current").attr("transform", "translate(" + (xLegend + 8) + "," + (chartHeight - 5) + ")rotate(-90)").attr("class", "label").attr("dy", ".7em");
		legend.append("rect").attr("width", 8).attr("height", 8).style("fill", function(d) {
			return d.rect1
		});
		legend.append("rect").attr("width", 8).attr("height", 8).attr("transform", "translate(8,0)").style("fill", function(d) {
			return d.rect2
		});
		legend.append("text").attr("class", "label").attr("x", 20).attr("y", 5).attr("dy", ".35em").text(function(d) {
			return d.name
		})
	}
};
var LeftHorizontalBar = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el;
	var minWidth = 250;
	var minHeight = 220;
	var defaultDimension = {
		width : 250,
		height : 220
	};
	var defaultMargin = {
		top : 20,
		right : 20,
		bottom : 20,
		left : 20
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	}
};
LeftHorizontalBar.prototype.draw = function() {
	var margin = this.margin, width = this.dimension.width, height = this.dimension.height, data = this.data, chartKey = this.chartKey;
	var myChartKey = {
		current_total : chartKey.current_total,
		current_total_percent : chartKey.current_total_percent,
		prev_total : chartKey.prev_total,
		prev_total_percent : chartKey.prev_total_percent,
		total_change : chartKey.total_change,
		total_change_percent : chartKey.total_change_percent,
		total_percent_change : chartKey.total_percent_change
	};
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var showName = typeof this.options.showName === "undefined" ? false : this.options.showName;
	var valueMode = this.options.valueMode ? this.options.valueMode.toLowerCase() : "number";
	if ( typeof this.options.subject !== "undefined")
		var subject = this.options.subject;
	if (valueMode == "percent") {
		var leftHorizontalBarFormat = d3.format(".1%");
		var axisFormat = d3.format(".0%");
		myChartKey.current_total = chartKey.current_total_percent;
		myChartKey.prev_total = chartKey.prev_total_percent
	} else {
		var leftHorizontalBarFormat = d3.format(".3s");
		var axisFormat = d3.format(".1s")
	}
	var sumPrev = d3.sum(data, function(d) {
		return d.value[myChartKey.prev_total]
	});
	var sumCurrent = d3.sum(data, function(d) {
		return d.value[myChartKey.current_total]
	});
	var maxSum = sumPrev > sumCurrent ? sumPrev : sumCurrent;
	var x = d3.scale.linear().domain([maxSum, 0]).range([0, chartWidth]);
	var yTemp = d3.scale.ordinal().domain(data.map(function(d) {
		return d.key
	})).rangeRoundBands([0, chartHeight], .7, 0);
	if (data.length > 1)
		var paddingBottom = (yTemp(data[1].key) - yTemp(data[0].key) - yTemp.rangeBand() * 2 - 2) / 2 + yTemp.rangeBand();
	else
		var paddingBottom = yTemp.rangeBand() / 2 + 10;
	var y = d3.scale.ordinal().domain(data.map(function(d) {
		return d.key
	})).rangeRoundBands([0, chartHeight - paddingBottom], .7, 0);
	function make_x_axis() {
		return d3.svg.axis().scale(x).orient("bottom").ticks(5).tickFormat(axisFormat)
	}

	var svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).attr("class", "horizontal bar").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	svg.append("g").attr("class", "grid").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis().ticks(5).tickSize(-chartHeight, 0, 0).tickFormat(""));
	var barGroup = svg.selectAll(".bar").data(data).enter().append("g");
	barGroup.append("rect").attr("class", "bar previous total").attr("x", function(d) {
		return x(d.value[myChartKey.prev_total])
	}).attr("y", function(d) {
		return y(d.key)
	}).attr("width", function(d) {
		return x(0) - x(d.value[myChartKey.prev_total])
	}).attr("height", y.rangeBand()).style("fill", "#d9d9d9").on("mouseover", function(d) {
		var s = util.displayName(d.key) + " (Previous Period) " + leftHorizontalBarFormat(d.value[myChartKey.prev_total]);
		if (valueMode == "percent")
			s += " (" + numberFormat(d.value[chartKey.prev_total]) + ")";
		util.tooltip.show(d3.event, s, {
			border : util.color(d.key, "border")
		})
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		var subjectToFetch = [];
		subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key;
		var conditions = {
			subject : subjectToFetch,
			channel : typeof subject !== "undefined" ? d.key : null,
			sentiment : null,
			talk : d.value[chartKey.prev_total],
			from : window.previousStartDate.getFullYear() + "-" + parseInt(parseInt(window.previousStartDate.getMonth()) + 1) + "-" + window.previousStartDate.getDate(),
			to : window.previousEndDate.getFullYear() + "-" + parseInt(parseInt(window.previousEndDate.getMonth()) + 1) + "-" + window.previousEndDate.getDate()
		};
		util.getPost(conditions)
	});
	barGroup.append("text").attr("class", "mini label").attr("dy", ".9em").attr("transform", function(d) {
		return "translate(" + (x(d.value[myChartKey.prev_total]) - labelMargin) + "," + y(d.key) + ")"
	}).style("text-anchor", "end").text(function(d) {
		return leftHorizontalBarFormat(d.value[myChartKey.prev_total])
	});
	barGroup.append("rect").attr("class", "bar current total").attr("x", function(d) {
		return x(d.value[myChartKey.current_total])
	}).attr("y", function(d) {
		return y(d.key) + y.rangeBand() + 1
	}).attr("width", function(d) {
		return x(0) - x(d.value[myChartKey.current_total])
	}).attr("height", y.rangeBand()).style("fill", function(d) {
		return util.color(d.key)
	}).on("mouseover", function(d) {
		var s = util.displayName(d.key) + " " + leftHorizontalBarFormat(d.value[myChartKey.current_total]);
		if (valueMode == "percent") {
			s = util.displayName(d.key) + " " + leftHorizontalBarFormat(d.value[myChartKey.current_total]) + " (" + numberFormat(d.value[chartKey.current_total]) + ")"
		}
		s += util.showChange(d.key, d.value[myChartKey.total_change], d.value[myChartKey.total_change_percent], d.value[myChartKey.total_percent_change], valueMode);
		util.tooltip.show(d3.event, s, {
			border : util.color(d.key, "border")
		});
		$(this).attr("style", "fill: " + util.color(d.key, "hover") + "; cursor: pointer;")
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).attr("style", "fill: " + util.color(d.key) + "; cursor: pointer;");
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		var subjectToFetch = [];
		subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key;
		var conditions = {
			subject : subjectToFetch,
			channel : typeof subject !== "undefined" ? d.key : null,
			sentiment : null,
			talk : d.value[chartKey.current_total]
		};
		util.getPost(conditions)
	});
	barGroup.append("text").attr("class", "mini label").attr("dy", ".9em").attr("transform", function(d) {
		return "translate(" + (x(d.value[myChartKey.current_total]) - labelMargin) + "," + (y(d.key) + y.rangeBand() + 1) + ")"
	}).style("text-anchor", "end").text(function(d) {
		return leftHorizontalBarFormat(d.value[myChartKey.current_total])
	});
	if (showName) {
		var nameMarginLeft = 30;
		var nameWidth = 119;
		barGroup.append("rect").attr("class", "name").attr("x", chartWidth + nameMarginLeft).attr("y", function(d) {
			return y(d.key)
		}).attr("width", nameWidth).attr("height", 2 * y.rangeBand() + 1).style("stroke", "#000").style("fill", "#fff");
		barGroup.append("text").attr("class", "label").attr("dy", ".7em").attr("transform", function(d) {
			return "translate(" + (chartWidth + nameMarginLeft + nameWidth / 2) + "," + (y(d.key) + y.rangeBand() / 2) + ")"
		}).text(function(d) {
			return util.trimLabel(util.displayName(d.key))
		}).style("text-anchor", "middle").on("mouseover", function(d) {
			var s = util.displayName(d.key);
			if (d.key.length > 12)
				util.tooltip.show(d3.event, s, {
					border : util.color(d.key, "border")
				})
		}).on("mousemove", function(d, i) {
			util.tooltip.move(d3.event)
		}).on("mouseout", function(d, i) {
			util.tooltip.hide(d3.event)
		})
	}
	barGroup.append("line").attr("class", "grid").attr("x1", 0).attr("y1", function(d) {
		return y(d.key) + 2.8 * y.rangeBand()
	}).attr("x2", chartWidth + margin.right).attr("y2", function(d) {
		return y(d.key) + 2.8 * y.rangeBand()
	}).style("visibility", function(d, i) {
		if (i == data.length - 1)
			return "hidden";
		else
			return "visible"
	});
	svg.append("line").attr("class", "axis").attr("x1", chartWidth).attr("y1", chartHeight).attr("x2", chartWidth + margin.right).attr("y2", chartHeight);
	svg.append("g").attr("class", "x axis label").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis());
	svg.append("g").attr("class", "y axis").append("line").attr("x1", x(0)).attr("x2", x(0)).attr("y2", chartHeight)
};
var RightHorizontalBar = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el;
	var minWidth = 250;
	var minHeight = 150;
	var defaultDimension = {
		width : 250,
		height : 220
	};
	var defaultMargin = {
		top : 10,
		right : 10,
		bottom : 20,
		left : 100
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	}
};
RightHorizontalBar.prototype.draw = function() {
	var margin = this.margin, width = this.dimension.width, height = this.dimension.height, data = this.data, chartKey = this.chartKey, myColor = typeof this.options.color === "undefined" ? "#d9d9d9" : this.options.color;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueMode = this.options.valueMode ? this.options.valueMode : "number";
	var myMax = d3.max(data, function(d) {
		return d.value[chartKey.data]
	});
	var max = this.options.max ? this.options.max : myMax;
	if ( typeof this.options.subject !== "undefined")
		var subject = this.options.subject;
	if ( typeof this.options.sentiment !== "undefined")
		var sentiment = this.options.sentiment;
	if ( typeof this.options.hasAuthor !== "undefined")
		var hasAuthor = this.options.hasAuthor;
	if (valueMode.toLowerCase() == "percent") {
		var RightHorizontalBarFormat = d3.format(".1%");
		var axisFormat = d3.format(".0%")
	} else {
		var RightHorizontalBarFormat = d3.format(".3s");
		var axisFormat = d3.format(".1s")
	}
	var x = d3.scale.linear().domain([0, max]).range([0, chartWidth]);
	var y = d3.scale.ordinal().domain(data.map(function(d) {
		return d.key
	})).rangeRoundBands([0, chartHeight], .3, 0);
	function make_x_axis() {
		return d3.svg.axis().scale(x).orient("bottom").ticks(5).tickFormat(axisFormat)
	}

	var svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).attr("class", "horizontal bar").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	svg.append("g").attr("class", "grid").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis().ticks(5).tickSize(-chartHeight, 0, 0).tickFormat(""));
	var barGroup = svg.selectAll(".bar").data(data).enter().append("g");
	barGroup.append("rect").attr("class", "bar").attr("x", 0).attr("y", function(d) {
		return y(d.key)
	}).attr("width", function(d) {
		return x(d.value[chartKey.data])
	}).attr("height", y.rangeBand()).style("fill", myColor).on("mouseover", function(d) {
		var color = util.increase_brightness(myColor, -20);
		$(this).attr("style", "fill: " + color + "; cursor: pointer;")
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		$(this).attr("style", "fill: " + myColor + "; cursor: pointer;");
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		var subjectToFetch = [];
		subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key;
		var conditions = {
			subject : subjectToFetch,
			author : typeof hasAuthor !== "undefined" && hasAuthor ? d.key : null,
			channel : typeof subject !== "undefined" && typeof hasAuthor === "undefined" ? d.key : null,
			sentiment : typeof sentiment !== "undefined" ? sentiment : null,
			talk : d.value[chartKey.data]
		};
		util.getPost(conditions)
	});
	barGroup.append("text").attr("class", "label").attr("dy", "1em").attr("transform", function(d) {
		return "translate(-5," + y(d.key) + ")"
	}).style("text-anchor", "end").text(function(d) {
		return util.displayName(d.key)
	});
	svg.append("g").attr("class", "y axis").append("line").attr("x1", x(0)).attr("x2", x(0)).attr("y2", chartHeight)
};
var Bubble = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el;
	var minWidth = 1;
	var minHeight = 1;
	var defaultDimension = {
		width : 300,
		height : 200
	};
	var defaultMargin = {
		top : 10,
		right : 20,
		bottom : 20,
		left : 40
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	}
};
Bubble.prototype.draw = function(object) {
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var data = this.data;
	var chartKey = this.chartKey;
	var yMinMax1 = d3.extent(data, function(d) {
		return d.value[chartKey.prev_avg_sentiments]
	});
	yMinMax1[0] = Math.abs(yMinMax1[0]);
	var yMinMax2 = d3.extent(data, function(d) {
		return d.value[chartKey.current_avg_sentiments]
	});
	yMinMax2[0] = Math.abs(yMinMax2[0]);
	var yAbsMax = Math.ceil(d3.max([yMinMax1[0], yMinMax1[1], yMinMax2[0], yMinMax2[1]]) * 100 * 1.1);
	var maxAvg = typeof this.options.maxAvg === "undefined" ? yAbsMax : this.options.maxAvg;
	if ( typeof this.options.subject !== "undefined")
		var subject = this.options.subject;
	if ( typeof this.options.otherSubjectArray !== "undefined")
		var otherSubjectArray = this.options.otherSubjectArray;
	var x = d3.scale.log().base(2).range([0, chartWidth]);
	var y = d3.scale.linear().range([chartHeight, 0]);
	x.domain([1, Math.pow(2, 20)]);
	y.domain([-(maxAvg / 100), maxAvg / 100]);
	var bubbleNumberFormat = d3.format(",.3s");
	var bubblePercentFormat = d3.format(".1%");
	function make_x_axis() {
		return d3.svg.axis().scale(x).orient("bottom").ticks(0)
	}

	function make_y_axis() {
		return d3.svg.axis().scale(y).orient("left").ticks(0)
	}

	var svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).attr("class", "bubble").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var bubbleZone = ["Niche", "Loyalty", "Weak", "Crisis"];
	var rectsGroup = svg.selectAll("rect").data(bubbleZone).enter().append("g").attr("class", function(d) {
		return "background " + d
	});
	rectsGroup.append("rect").attr("width", chartWidth / 2).attr("height", chartHeight / 2).attr("class", function(d) {
		return d
	});
	svg.select("." + bubbleZone[1]).attr("transform", "translate(" + chartWidth / 2 + ",0)");
	svg.select("." + bubbleZone[2]).attr("transform", "translate(0," + chartHeight / 2 + ")");
	svg.select("." + bubbleZone[3]).attr("transform", "translate(" + chartWidth / 2 + "," + chartHeight / 2 + ")");
	svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis().ticks(2));
	svg.append("g").attr("class", "y axis").call(make_y_axis());
	svg.append("g").attr("class", "grid").attr("transform", "translate(0," + chartHeight + ")").call(make_x_axis().tickSize(-chartHeight, 0, 0).tickFormat(""));
	svg.append("g").attr("class", "grid").call(make_y_axis().tickSize(-chartWidth, 0, 0).tickFormat(""));
	var zoneLabels = svg.append("g").selectAll(".zoneLabel").data(bubbleZone).enter().append("text").text(function(d) {
		return d
	}).attr("class", function(d) {
		return "zoneLabel " + d
	});
	var labelMargin = 10;
	svg.select("text." + bubbleZone[0]).attr("transform", "translate(" + labelMargin + "," + labelMargin * 2 + ")");
	svg.select("text." + bubbleZone[1]).attr("transform", "translate(" + (chartWidth - 50) + "," + labelMargin * 2 + ")");
	svg.select("text." + bubbleZone[2]).attr("transform", "translate(" + labelMargin + "," + (chartHeight - labelMargin) + ")");
	svg.select("text." + bubbleZone[3]).attr("transform", "translate(" + (chartWidth - 50) + "," + (chartHeight - labelMargin) + ")");
	var labels = [];
	for (var i in data) {
		var name = data[i].key.replace(" (Previous Period)", "");
		if (labels.indexOf(name) < 0)
			labels.push(name)
	}
	svg.append("g").attr("class", "legend").attr("transform", "translate(10,10)");
	var legendGroup = svg.select("g.legend").selectAll("g.legend").data(labels).enter().append("g").attr("transform", function(d, i) {
		return "translate(0," + (i + 1) * 14 + ")"
	});
	legendGroup.append("rect").attr("width", 10).attr("height", 10).attr("class", "previous").style("fill", function(d, i) {
		return "#d9d9d9"
	}).style("stroke", function(d, i) {
		return util.color(d, "border")
	});
	legendGroup.append("rect").attr("width", 10).attr("height", 10).attr("transform", "translate(10,0)").style("fill", function(d, i) {
		return util.color(d)
	}).style("stroke", function(d, i) {
		return util.color(d, "border")
	});
	legendGroup.append("text").attr("class", "label").attr("x", 22).attr("y", 5).attr("dy", ".35em").style("fill", function(d, i) {
		return util.color(d, "text")
	}).text(function(d) {
		return util.trimLabel(util.displayName(d))
	});
	var lineGroups = svg.selectAll("g.line").data(data).enter().append("g").attr("class", "line");
	lineGroups.append("line").attr("x1", function(d) {
		return x(d.value[chartKey.prev_postcount])
	}).attr("x2", function(d) {
		return x(d.value[chartKey.current_postcount])
	}).attr("y1", function(d) {
		return y(d.value[chartKey.prev_avg_sentiments])
	}).attr("y2", function(d) {
		return y(d.value[chartKey.current_avg_sentiments])
	}).style("stroke", function(d) {
		return util.color(d.key, "border")
	});
	var circleGroups = svg.selectAll(".circle_group").data(data.reverse()).enter().append("g").attr("class", "circle_group");
	var prev_circles = circleGroups.append("circle").attr("transform", function(d) {
		var xxx = d.value[chartKey.prev_postcount];
		if (xxx < 1)
			xxx = 1;
		return "translate(" + x(xxx) + "," + y(d.value[chartKey.prev_avg_sentiments]) + ")"
	}).attr("r", 8).style("fill", function(d) {
		return "#d9d9d9"
	}).style("stroke", function(d) {
		return util.color(d.key, "border")
	}).on("mouseover", function(d) {
		var title = util.displayName(d.key) + " (Previous Period)<br />";
		var pc = d.value[chartKey.prev_postcount] / 1e3;
		if (pc < .1)
			pc = "<0.1";
		else
			pc = bubbleNumberFormat(pc);
		title += "Post count: " + bubbleNumberFormat(d.value[chartKey.prev_postcount]) + " " + "<br />";
		title += "Average sentiment: " + bubblePercentFormat(d.value[chartKey.prev_avg_sentiments]) + " ";
		util.tooltip.show(d3.event, title, {
			border : util.color(d.key, "border")
		})
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key;
		// } else {
			// var subjectToFetch = otherSubjectArray;
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof subject !== "undefined" ? d.key : null,
			// sentiment : null,
			// talk : d.value[chartKey.prev_postcount],
			// from : window.previousStartDate.getFullYear() + "-" + parseInt(parseInt(window.previousStartDate.getMonth()) + 1) + "-" + window.previousStartDate.getDate(),
			// to : window.previousEndDate.getFullYear() + "-" + parseInt(parseInt(window.previousEndDate.getMonth()) + 1) + "-" + window.previousEndDate.getDate()
		// };
		// util.getPost(conditions);
		object.onClick(d);
	});
	var current_circles = circleGroups.append("circle").attr("transform", function(d) {
		var xxx = d.value[chartKey.current_postcount];
		if (xxx < 1)
			xxx = 1;
		return "translate(" + x(xxx) + "," + y(d.value[chartKey.current_avg_sentiments]) + ")"
	}).attr("r", 8).style("fill", function(d) {
		return util.color(d.key)
	}).style("stroke", function(d) {
		return util.color(d.key, "border")
	}).on("mouseover", function(d) {
		var title = util.displayName(d.key) + "<br />";
		var prefix = "";
		if (d.value[chartKey.postcount_change] > 0)
			prefix = "+";
		title += "Post count: " + bubbleNumberFormat(d.value[chartKey.current_postcount]) + " (" + prefix + bubbleNumberFormat(d.value[chartKey.postcount_change]) + ")<br />";
		prefix = "";
		if (d.value[chartKey.avg_sentiments_change] > 0)
			prefix = "+";
		title += "Average sentiment: " + bubblePercentFormat(d.value[chartKey.current_avg_sentiments]) + " (" + bubblePercentFormat(d.value[chartKey.avg_sentiments_change]) + ")";
		util.tooltip.show(d3.event, title, {
			border : util.color(d.key, "border")
		})
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event)
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event)
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.key;
		// } else {
			// var subjectToFetch = otherSubjectArray;
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof subject !== "undefined" ? d.key : null,
			// sentiment : null,
			// talk : d.value[chartKey.current_postcount]
		// };
		// util.getPost(conditions);
		object.onClick(d);
	});
	var axisLabel = svg.append("g").attr("class", "label");
	axisLabel.append("text").text("Sentiments").attr("transform", "translate(-10," + (chartHeight / 2 + 30) + ")rotate(270)");
	axisLabel.append("text").text("High").attr("transform", "translate(-30,0)").attr("dy", ".3em");
	axisLabel.append("text").text("Low").attr("transform", "translate(-30," + chartHeight + ")").attr("dy", ".3em");
	axisLabel.append("text").text("Talks").attr("transform", "translate(" + chartWidth / 2 + "," + (chartHeight + 13) + ")").style("text-anchor", "middle").attr("dy", ".3em");
	axisLabel.append("text").text("Low").attr("transform", "translate(0," + (chartHeight + 13) + ")").attr("dy", ".3em").style("text-anchor", "middle");
	axisLabel.append("text").text("High").attr("transform", "translate(" + chartWidth + "," + (chartHeight + 13) + ")").attr("dy", ".3em").style("text-anchor", "middle");
};
var animationDurationForPie = 700;
var Pie = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el;
	var minWidth = 1;
	var minHeight = 140;
	var defaultDimension = {
		width : 300,
		height : 140
	};
	var defaultMargin = {
		top : 20,
		right : 30,
		bottom : 20,
		left : 120
	};
	if ( typeof this.options.showLegend === "undefined")
		this.options.showLegend = true;
	if (this.options.showLegend !== true) {
		minWidth = 150;
		minHeight = 115;
		defaultMargin = {
			top : 10,
			right : 5,
			bottom : 5,
			left : 5
		};
	}
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	// var margin = this.margin = {
		// top : 20,
		// right : 30,
		// bottom : 20,
		// left : 120
	// };
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	// var dimension = this.dimension = {
		// width : 375,
		// height : 250
	// };
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	}
};
Pie.prototype.draw = function(object) {
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var data = this.data;
	var chartKey = this.chartKey;
	var radius = Math.min(chartWidth, chartHeight) / 2;
	var dx = this.options.dx ? this.options.dx : 0;
	var dy = this.options.dy ? this.options.dy : 0;
	var donutWidth = this.options.donutWidth ? this.options.donutWidth : 20;
	var showLegend = typeof this.options.showLegend === "undefined" ? true : this.options.showLegend;
	var labelDistance = typeof this.options.labelDistance === "undefined" ? 1.5 : this.options.labelDistance;
	var valueMode = this.options.valueMode ? this.options.valueMode.toLowerCase() : "number";
	if ( typeof this.options.subject !== "undefined")
		var subject = this.options.subject;
	if ( typeof this.options.channel !== "undefined")
		var channel = this.options.channel;
	if ( typeof this.options.otherSubjectArray !== "undefined")
		var otherSubjectArray = this.options.otherSubjectArray;
	var notShowNumber = .07;
	var sum = d3.sum(data, function(d) {
		return d.value[chartKey.previous];
	});
	var sum2 = d3.sum(data, function(d) {
		return d.value[chartKey.current];
	});
	var siFormat = d3.format(".3s");
	if (valueMode == "percent") {
		var numberFormat = d3.format(".1%");
		var scale = d3.scale.linear().range([0, 1]).domain([0, sum]);
		var scale2 = d3.scale.linear().range([0, 1]).domain([0, sum2]);
	} else {
		var numberFormat = d3.format(".3s");
		var scale = d3.scale.linear().range([0, sum]).domain([0, sum]);
		var scale2 = d3.scale.linear().range([0, sum2]).domain([0, sum2]);
	}
	var cx = margin.left + chartWidth / 2;
	var cy = margin.top + chartHeight / 2;
	var svg = d3.select(this.el).append("svg").attr("class", "pie").data([data]).attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + cx + "," + cy + ")");
	var outerPie = d3.layout.pie().value(function(d) {
		return d.value[chartKey.current];
	}).sort(null);
	var outerArc = d3.svg.arc().innerRadius(radius - donutWidth).outerRadius(radius - 0);
	var outerArcs = svg.selectAll("g.outerSlice").data(outerPie).enter().append("g").attr("class", "outerSlice current");
	outerDoughnut = outerArcs.append("path").attr("fill", function(d) {
		return util.color(d.data.key);
	}).attr("d", outerArc).on("mouseover", function(d, i) {
		// console.log(d.data.key);
		var s = util.displayName(d.data.key) + " " + numberFormat(scale2(d.value));
		if (valueMode == "percent") {
			var s = util.displayName(d.data.key) + " " + numberFormat(scale2(d.value)) + " (" + siFormat(d.value) + ")";
		}
		s += util.showChange(util.displayName(d.data.key), data[i].value[chartKey.change], data[i].value[chartKey.change_percent], data[i].value[chartKey.percent_change], valueMode);
		util.tooltip.show(d3.event, s, {
			border : util.color(d.data.key)
		});
		$(this).attr("fill", util.color(d.data.key, "hover"));
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event);
	}).on("mouseout", function(d, i) {
		util.tooltip.hide(d3.event);
		$(this).attr("fill", util.color(d.data.key));
	}).style("cursor", "pointer").on("click", function(d) {
		// console.log(d);
		// if (d.data.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.data.key
		// } else {
			// var subjectToFetch = otherSubjectArray
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof channel !== "undefined" ? channel : null,
			// sentiment : null,
			// talk : d.value
		// };
		// util.getPost(conditions)
		d.time = 'current';
		object.onClick(d);
	});
	outerArcs.append("text").attr("class", "mini label").attr("transform", function(d) {
		var c = outerArc.centroid(d);
		return "translate(" + c[0] * labelDistance + "," + c[1] * labelDistance + ")";
	}).attr("dy", ".5em").style("text-anchor", "middle").style("fill", function(d, i) {
		return util.color(d.data.key);
	}).text(function(d) {
		return d.data.value[chartKey.current] / sum2 < notShowNumber ? "" : numberFormat(scale2(d.value));
	});
	var innerPie = d3.layout.pie().value(function(d) {
		return d.value[chartKey.previous];
	}).sort(null);
	var innerArc = d3.svg.arc().innerRadius(radius - donutWidth * 2).outerRadius(radius - donutWidth);
	var innerArcs = svg.selectAll("g.innerSlice").data(innerPie).enter().append("g").attr("class", "innerSlice previous");
	innerDoughnut = innerArcs.append("path").attr("class", "donut inner").attr("fill", function(d) {
		return util.color(d.data.key);
	}).attr("d", innerArc).attr("hover", function(d) {
		return util.color(d.data.key, "hover");
	}).on("mouseover", function(d, i) {
		var s = util.displayName(d.data.key) + " (Previous Period) " + numberFormat(scale(d.value));
		if (valueMode == "percent")
			s += " (" + siFormat(d.value) + ")";
		util.tooltip.show(d3.event, s, {
			border : util.color(d.data.key)
		});
		$(this).attr("fill", util.color(d.data.key, "hover"));
	}).on("mousemove", function(d, i) {
		util.tooltip.move(d3.event);
	}).on("mouseout", function(d, i) {
		$(this).attr("fill", util.color(d.data.key));
		util.tooltip.hide(d3.event);
	}).style("cursor", "pointer").on("click", function(d) {
		// if (d.data.key != "Other") {
			// var subjectToFetch = [];
			// subjectToFetch[0] = typeof subject !== "undefined" ? subject : d.data.key
		// } else {
			// var subjectToFetch = otherSubjectArray
		// }
		// var conditions = {
			// subject : subjectToFetch,
			// channel : typeof channel !== "undefined" ? channel : null,
			// sentiment : null,
			// talk : d.value,
			// from : window.previousStartDate.getFullYear() + "-" + parseInt(parseInt(window.previousStartDate.getMonth()) + 1) + "-" + window.previousStartDate.getDate(),
			// to : window.previousEndDate.getFullYear() + "-" + parseInt(parseInt(window.previousEndDate.getMonth()) + 1) + "-" + window.previousEndDate.getDate()
		// };
		// util.getPost(conditions)
		d.time = 'past';
		object.onClick(d);
	});
	if (!disableAnimation || typeof disableAnimation == "undefined") {
		innerDoughnut.transition().duration(animationDurationForPie).ease("quad").attrTween("d", function(d) {
			var fromAngle = d.startAngle;
			var toAngle = d.endAngle;
			var interpolate = d3.interpolate(fromAngle, toAngle);
			return function(t) {
				d.endAngle = interpolate(t);
				return innerArc(d);
			};
		});
		outerDoughnut.transition().duration(animationDurationForPie).ease("quad").attrTween("d", function(d) {
			var fromAngle = d.startAngle;
			var toAngle = d.endAngle;
			var interpolate = d3.interpolate(fromAngle, toAngle);
			return function(t) {
				d.endAngle = interpolate(t);
				return outerArc(d);
			};
		});
	}
	if (showLegend) {
		var topMargin = chartHeight / 2 - 30;
		var legend = svg.append("g").attr("class", "legend").attr("transform", "translate(-" + cx + ",-" + topMargin + ")").selectAll("g.label").data(data).enter().append("g").attr("transform", function(d, i) {
			return "translate(0," + (i + 1) * 14 + ")";
		});
		svg.select("g.legend").append("text").text("Previous").attr("transform", "translate(8,6)rotate(-90)").attr("class", "label");
		svg.select("g.legend").append("text").text("Current").attr("transform", "translate(18,6)rotate(-90)").attr("class", "label");
		legend.append("rect").attr("width", 10).attr("height", 10).attr("class", "previous").style("fill", function(d, i) {
			return util.color(d.key);
		});
		legend.append("rect").attr("width", 10).attr("height", 10).attr("transform", "translate(10,0)").style("fill", function(d, i) {
			return util.color(d.key);
		});
		legend.append("text").attr("class", "label").attr("x", 22).attr("y", 5).attr("dy", ".35em").style("fill", function(d, i) {
			return util.color(d.key);
		}).text(function(d) {
			return util.trimLabel(util.displayName(d.key));
		});
	}
};
var animationDurationForLine = 700;
var intFormat = d3.format(",");
var LineChart = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el || "body";
	var minWidth = 170;
	var minHeight = 120;
	var defaultDimension = {
		width : 300,
		height : 150
	};
	var defaultMargin = {
		top : 10,
		right : 50,
		bottom : 50,
		left : 50
	};
	if (options.disableXAxis === true && options.disableYAxisLabel === true && options.abbreviateYAxisLabel === true) {
		minWidth = 150;
		minHeight = 10;
		defaultMargin = {
			top : 10,
			right : 0,
			bottom : 20,
			left : 20
		};
	}
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth;
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight;
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	};
	var indexTotal = null;
	var x = this.x = d3.time.scale().range([0, chartDimension.width]);
	var y = this.y = d3.scale.linear().range([chartDimension.height, 0]);
	this.xAxis = d3.svg.axis().scale(this.x).orient("bottom").ticks(d3.time.day, 7).tickFormat(d3.time.format("%e %b"));
	this.yAxis = d3.svg.axis().scale(this.y).orient("left").ticks(0);
	var xDomain = d3.extent(data, function(d) {
		return d[chartKey.x];
	});
	x.domain(xDomain);
	var yKey = chartKey.y;
	var yRawDomain = [];
	var highest_data_value = 0;
	var lowest_data_value = 9999999999999;
	for (var i = 0; i < yKey.length; i++) {
		if (yKey[i] != "total") {
			yRawDomain = yRawDomain.concat(d3.extent(data, function(d) {
				// console.log(d.data[i].value);
				if(d.data[i].value > highest_data_value){
					highest_data_value = d.data[i].value;
				}
				if(d.data[i].value < lowest_data_value){
					lowest_data_value = d.data[i].value;
				}
				return d.data[i].value;
			}));
		} else {
			indexTotal = i;
		}
	}
	this.highest_data_value = highest_data_value;
	this.lowest_data_value = lowest_data_value;
	var yForTotal = null;
	if (indexTotal != null) {
		var yTotalDomain = d3.extent(data, function(d) {
			return d.value.total;
		});
		var yForTotal = this.yForTotal = d3.scale.linear().range([this.dimension.height, 0]).domain(yTotalDomain);
	}
	var yDomain = d3.extent(yRawDomain, function(d) {
		return d;
	});
	y.domain(yDomain);
	//console.log(yRawDomain);
};
LineChart.prototype.draw = function(object) {
	var self = this;
	var options = this.options;
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueLine = this.valueLine;
	var data = this.data;
	var chartKey = this.chartKey;
	var yKey = chartKey.y;
	var valueMode = this.options.valueMode ? this.options.valueMode : "number";
	if ( typeof this.options.subject !== "undefined")
		var subject = this.options.subject;
	if ( typeof this.options.otherSubjectArray !== "undefined")
		var otherSubjectArray = this.options.otherSubjectArray;
	var LineFormat = d3.format(".3s");
	if (valueMode.toLowerCase() == "percent") {
		LineFormat = d3.format(".1%");
	}
	var maxDate = _.max(this.data,function(row){return row[chartKey.x];})[chartKey.x];
	var minDate = _.min(this.data,function(row){return row[chartKey.x];})[chartKey.x];
	var svg = this.svg = d3.select(this.el).append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var yAxisHighLabel = "High";
	var yAxisLowLabel = "Low";
	if (options.abbreviateYAxisLabel) {
		var _highest_data_value = this.highest_data_value;
		if(this.highest_data_value >= 1000 || this.highest_data_value <= -1000){
			_highest_data_value = this.highest_data_value / 1000;
			_highest_data_value = Math.round( _highest_data_value * 10 ) / 10;
			_highest_data_value = _highest_data_value+'k';
		}
		yAxisHighLabel = _highest_data_value;
		var _lowest_data_value = this.lowest_data_value;
		if(this.lowest_data_value >= 1000 || this.lowest_data_value <= -1000){
			_lowest_data_value = this.lowest_data_value / 1000;
			_lowest_data_value = Math.round( _lowest_data_value * 10 ) / 10;
			_lowest_data_value = _lowest_data_value+'k';
		}
		yAxisLowLabel = _lowest_data_value;
	}
	if (!options.disableYAxis) {
		var yAxis = svg.append("g").attr("class", "y axis").call(this.yAxis);
		yAxis.append("text").attr("class", "label").attr("transform", "translate(-9,0)").attr("dy", ".32em").style("text-anchor", "end").text(yAxisHighLabel);
		yAxis.append("text").attr("font-size", "10px").attr("class", "label").attr("transform", "translate(-9," + chartHeight + ")").attr("dy", ".32em").style("text-anchor", "end").text(yAxisLowLabel);
		if (!options.disableYAxisLabel || options.yAxisLabel) {
			var label = options.yAxisLabel || "Sentiments";
			svg.append("text").attr("class", "label").attr("transform", "rotate(-90)").attr("x", 0 - chartHeight / 2).attr("y", 0).attr("dy", "-1.5em").style("text-anchor", "middle").text(label);
		}
	}
	svg.append("g").attr("class", "grid").call(d3.svg.axis().scale(this.y).orient("left").ticks(5).tickSize(-chartWidth, 0, 0).tickFormat(""));
	svg.append("g").attr("class", "grid").call(d3.svg.axis().scale(this.x).orient("bottom").ticks(d3.time.day, 7).tickSize(chartHeight, 0, 0).tickFormat(""));
	// console.log(data);
	for (var i = 0; i < yKey.length; i++) {
		var valueLine = d3.svg.line().x(function(d) {
			return self.x(d[chartKey.x]);
		}).y(function(d) {
			// console.log(d.data[i], i, d.value[yKey[i]]);
			if(typeof ((d.data[i])) !== "undefined"){
				return self.y(d.data[i].value);
			}
			// return self.y(d.value[yKey[i]]);
		});
		path = svg.append("path").attr("d", valueLine(data)).attr("stroke-width", 2).attr("fill", "none").style("stroke", util.color(yKey[i]));
		if (!disableAnimation || typeof disableAnimation == "undefined") {
			var totalLength = path.node().getTotalLength();
			path.attr("stroke-dasharray", totalLength + " " + totalLength).attr("stroke-dashoffset", totalLength).transition().duration(animationDurationForLine).ease("linear").attr("stroke-dashoffset", 0);
		}
		var dotLayer = svg.append("g").selectAll("dot").data(data).enter().append("g");
		dotLayer.append("circle").attr("r", 5).attr("cx", function(d) {
			return self.x(d[chartKey.x]);
		}).attr("cy", function(d) {
			//return self.y(d.value[yKey[i]]);
			return self.y(d.data[i].value);
		}).style("opacity", "0").style("fill", util.color(yKey[i])).attr("data", yKey[i]).on("mouseover", function(d, i) {
			$(this).css("opacity", "1");
			var yKey = $(this).attr("data");
			//find value in y axit
			var y_value = '';
			var color = '';
			for(var i=0;i<(d.data).length;i++){
				if(d.data[i].key === yKey){
					y_value = d.data[i].value;
					color = d.data[i].color;
					break;
				}
			}
			var str = d3.time.format("%e %b")(d.key) + " " + yKey + " " + LineFormat(y_value);
			// console.log(d, i, yKey);
			util.tooltip.show(d3.event, str, {
				border : util.color(yKey)//border : util.color(d.data[i].color)
			});
		}).on("mousemove", function(d, i) {
			$(this).css("opacity", "1");
			var yKey = $(this).attr("data");
			// console.log(yKey);
			util.tooltip.move(d3.event);
		}).on("mouseout", function(d, i) {
			$(this).css("opacity", "0");
			util.tooltip.hide(d3.event);
		}).style("cursor", "pointer").on("click", function(d, i) {
			d.name = yKey;
			object.onClick(d);
			// var yKey = $(this).attr("data");
			// if (yKey != "Other") {
				// var subjectToFetch = [];
				// subjectToFetch[0] = typeof subject !== "undefined" ? subject : yKey;
			// } else {
				// var subjectToFetch = otherSubjectArray;
			// }
			// var conditions = {
				// subject : subjectToFetch,
				// channel : null,
				// sentiment : yKey === "negative" ? -1 : yKey === "positive" ? 1 : null,
				// from : d3.time.format("%Y-%m-%d")(d.key),
				// to : d3.time.format("%Y-%m-%d")(d.key),
				// talk : d.value[yKey]
			// };
			// util.getPost(conditions);
		});
	}
	if (!options.disableXAxis) {
		var xAxis = svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chartHeight + ")").call(this.xAxis);
		xAxis.selectAll("text").attr("class", "label");
	}
	svg.append("text").attr("class", "label").attr("x", chartWidth / 2).attr("y", chartHeight).attr("dy", "3em").style("text-anchor", "middle").text("Talks");
	if (options.showLegend) {
		var cYOfLegend = chartHeight / 2 - 30;
		var legend = svg.append("g").attr("transform", "translate(0, " + cYOfLegend + ")");
		for (var i = 0; i < yKey.length; i++) {
			var legendItemLayer = legend.append("g");
			legendItemLayer.append("line").attr("x1", -margin.left + 10).attr("y1", cYOfLegend).attr("x2", -margin.left + 10 + 10).attr("y2", cYOfLegend).attr("dy", ".3em").attr("stroke-width", 2).style("stroke", util.color(yKey[i]));
			legendItemLayer.append("text").attr("x", -margin.left + 10 + 10 + 10).attr("y", cYOfLegend).attr("dy", ".3em").attr("class", "label").text(yKey[i]);
			cYOfLegend += 20;
		}
	}
};
LineChart.prototype.update = function() {
};
var animationDurationFor2SidesBar = 700;
var TwoSideBarChart = function(el, data, chartKey, options) {
	data = data || [];
	options = options || {};
	this.data = data;
	this.options = options;
	this.chartKey = chartKey;
	this.el = el || "body";
	var minWidth = 45;
	var minHeight = 20;
	var defaultDimension = {
		width : 45,
		height : 20
	};
	var defaultMargin = {
		top : 0,
		right : 0,
		bottom : 0,
		left : 0
	};
	options.margin = options.margin || {};
	var margin = this.margin = _.defaults(options.margin, defaultMargin);
	options.dimension = options.dimension || {};
	var dimension = this.dimension = _.defaults(options.dimension, defaultDimension);
	if (dimension.width < minWidth) {
		dimension.width = minWidth
	}
	if (dimension.height < minHeight) {
		dimension.height = minHeight
	}
	var chartDimension = this.chartDimension = {
		width : dimension.width - margin.left - margin.right,
		height : dimension.height - margin.top - margin.bottom
	}
};
TwoSideBarChart.prototype.draw = function(object) {
	var self = this;
	var margin = this.margin;
	var width = this.dimension.width;
	var height = this.dimension.height;
	var chartWidth = this.chartDimension.width;
	var chartHeight = this.chartDimension.height;
	var valueLine = this.valueLine;
	var data = this.data;
	var chartKey = this.chartKey;
	var yKey = chartKey.y;
	var color = this.options.color;
	var svg = this.svg = d3.select(this.el).append("svg").attr("width", "100%").attr("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	var barWidth = chartWidth / data.length;
	var xDomain = d3.extent(data, function(d) {
		return d[chartKey.x]
	});
	var maxY1 = _.max(this.data,function(row){return row.value[yKey[0]]}).value[yKey[0]];
	var min = _.min(this.data,function(row){return row.value[yKey[0]]}).value[yKey[0]];
	var absMax = Math.max(Math.abs(min), maxY1);
	if (absMax <= .15) {
		absMax = .15
	} else {
		absMax = Math.ceil(absMax * 100 / 5) * 5 / 100
	}
	var x = this.x = d3.time.scale().range([0, chartWidth]).domain(xDomain);
	var y = d3.scale.linear().domain([-absMax, absMax]).range([chartHeight, 0]);
	var barGroup = svg.selectAll(".bar").data(data).enter().append("g");
	barGroup.append("rect").attr("class", function(d) {
		return d.value[yKey[0]] >= 0 ? "bar positive barup" : "bar negative bardown"
	}).attr("x", function(d, i) {
		return x(d.key)
	}).attr("y", function(d, i) {
		return y(Math.max(0, d.value[yKey[0]]))
	}).attr("width", barWidth).attr("height", function(d) {
		return Math.abs(y(d.value[yKey[0]]) - y(0))
	}).style("fill", function(d) {
		return d.value[yKey[0]] >= 0 ? "#9bbb59" : "#f79646"
	}).style("cursor", "pointer").on("click", function(d) {
		object.onClick(d);
	});
	if (!disableAnimation || typeof disableAnimation == "undefined") {
		animatedBar = d3.selectAll("rect.bar.positive.barup");
		animatedBar.attr("y", y(0)).attr("height", 0).transition().duration(animationDurationFor2SidesBar).ease("quad").attr("y", function(d, i) {
			return y(Math.max(0, d.value[yKey[0]]))
		}).attr("height", function(d) {
			return Math.abs(y(d.value[yKey[0]]) - y(0))
		});
		animatedBar = d3.selectAll("rect.bar.negative.bardown");
		animatedBar.attr("y", y(0)).attr("height", 0).transition().duration(animationDurationFor2SidesBar).ease("quad").attr("y", function(d, i) {
			return y(Math.max(0, d.value[yKey[0]]))
		}).attr("height", function(d) {
			return Math.abs(y(d.value[yKey[0]]) - y(0))
		})
	}
};
TwoSideBarChart.prototype.update = function() {
}; 